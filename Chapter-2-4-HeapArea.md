#### JVM Heap Area

##### 内存划分

**结构：** 

- 新生代：新对象 和 没达到一定年龄的对象
- 老年代：被长时间使用的对象/超过新生代设置的阈值大小的 ”大对象“
- 元空间：一些方法中的操作临时对象，JDK1.8前占用JVM内存，JDK1.8之后直接使用物理内存 （方法区，又被称为non heap）

![image](https://s3.bmp.ovh/imgs/2022/07/29/8602e22486666b1f.jpg)

（before JDK1.8 after JDK1.8 ）

![image](https://s3.bmp.ovh/imgs/2022/07/29/c4bbef3c6edb872d.jpg)

**不连续物理空间、固定/可扩展大小、OOM异常**

Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。

实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 `-Xmx` 和 `-Xms` 控制）

如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 `OutOfMemoryError` 异常。

##### 新生代

构成：Eden（伊甸园）+ S0 + S1 （survivor0/1）

**Minor GC、8：1：1**

年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 **Minor GC**。

年轻一代被分为三个部分——伊甸园（**Eden Memory**）和两个幸存区（**Survivor Memory**，被称为from/to或s0/s1），默认比例是`8:1:1`



**新生代Minor GC机制**

1. 大多数新创建的对象都位于 Eden 内存空间中

2. 当 Eden 空间被对象填充时，执行**Minor GC**，并将所有幸存者对象移动到一个幸存者空间中

3. Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的

4. 经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代

##### 老年代

旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。

**BIG object处理**

大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是**避免**在 Eden 区和两个Survivor 区之间**发生大量的内存拷贝**

##### 堆内存大小设置 以及 OOM

Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 `-Xmx` 和 `-Xms` 来设定

- `-Xms` 用来表示堆的起始内存，等价于 `-XX:InitialHeapSize`
- `-Xmx` 用来表示堆的最大内存，等价于 `-XX:MaxHeapSize`

如果堆的内存大小超过 `-Xmx` 设定的最大内存， 就会抛出 `OutOfMemoryError` 异常。

我们通常会将 `-Xmx` 和 `-Xms` 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能

- 默认情况下，初始堆内存大小为：电脑内存大小/64
- 默认情况下，最大堆内存大小为：电脑内存大小/4



##### 查看JVM堆内存分配

1. 在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小

2. 默认情况下新生代和老年代的比例是 1:2，可以通过 `–XX:NewRatio` 来配置
   - 新生代中的 **Eden**:**From Survivor**:**To Survivor** 的比例是 **8:1:1**，可以通过 `-XX:SurvivorRatio` 来配置

​	每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小，计算依据是**GC	过程**中统计的**GC时间**、**吞吐量**、**内存占用量**



##### 对象在堆中的生命周期

在 JVM 内存模型的堆中，堆被划分为新生代和老年代

- 新生代又被进一步划分为 **Eden区** 和 **Survivor区**，Survivor 区由 **From Survivor** 和 **To Survivor** 组成

当创建一个对象时，对象会被优先分配到新生代的 Eden 区

- 此时 JVM 会给对象定义一个**对象年轻计数器**（`-XX:MaxTenuringThreshold`）

当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）

- JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1
- 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会+1

如果分配的对象超过了`-XX:PetenureSizeThreshold`，对象会**直接被分配到老年代**



##### 对象分配过程

1. new 的对象先放在伊甸园区，此区有大小限制

2. 当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区

   然后将伊甸园中的剩余对象移动到幸存者 0 区

3. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区，如果没有回收，就会放到幸存者 1 区

4. 如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区

什么时候才会去养老区呢？： 默认是 15 次回收标记

5. 在养老区，相对悠闲。当养老区内存不足时，再次触发 Major GC，进行养老区的内存清理

OOM：若养老区执行了 Major GC  之后发现依然无法进行对象的保存，就会产生 OOM 异常

### GC 垃圾回收简介

#### Minor GC、Major GC、Full GC

JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full  GC）

- 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为：
  - 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
  - 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集
    - 目前，只有 CMS GC 会有单独收集老年代的行为
    - 很多时候 Major GC 会和 Full GC  混合使用，需要具体分辨是老年代回收还是整堆回收
  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
    - 目前只有 G1 GC 会有这种行为
- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾



### TLAB

#### (#什么是-tlab-thread-local-allocation-buffer) 什么是 TLAB （Thread Local Allocation Buffer）?

- 从内存模型而不是垃圾回收的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内
- 多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因此我们可以将这种内存分配方式称为**快速分配策略**
- OpenJDK 衍生出来的 JVM 大都提供了 TLAB 设计

好处：不用上锁却线程安全 ---> 更快

#### (#为什么要有-tlab)为什么要有 TLAB ?

- 堆区是线程共享的，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度

尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将 TLAB 作为内存分配的首选。

**开启/关闭：**在程序中，可以通过 `-XX:UseTLAB` 设置是否开启 TLAB 空间。

**设置大小：**默认情况下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，我们可以通过 `-XX:TLABWasteTargetPercent` 设置 TLAB 空间所占用 Eden 空间的百分比大小。

**如果TLAB失败：**一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。

