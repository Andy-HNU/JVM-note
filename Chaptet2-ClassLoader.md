#### ClassLoader

##### 类加载机制

- 类加载

  1. Math.class 读入内存
  2. 加载到JVM的方法区内（still in Memory）
  3. 在JVM堆区创建 Class.obj 对象

- 类加载过程

  类加载的**生命周期**：加载（Loading）-->验证（Verification）-->准备（Preparation）-->解析（Resolution）-->初始化（Initialization）-->使用（Using）-->卸载（Unloading）

  1. 加载：IO读入字节码 --> 存储至JVM方法区--> 创建对象java.lang.Class

     ​    a) 加载阶段的工作

     ​    	i. 通过**一个类的全限定名**来获取定义此类的二进制字节流。

     ​    	ii. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

     ​    	iii. 在java**堆中生成一个代表这个类的java.lang.Class对象**，做为方法区这些数据的访问入口。

     ​    b) 加载阶段完成之后二进制字节流就按照虚拟机所需的格式存储在方法区中。

  2. 链接：

     1. 验证：

        1. 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。

        2. a) 文件格式验证：验证字节流是否符合Class**文件格式的规范**，并且能被当前版本的虚拟机处理。

           b) 元数据验证：对字节码描述的信息进行语义分析，以确保其描述的信息**符合java语言规范**的要求。

           c) 字节码验证：这个阶段的主要工作是进行数据流和控制流的分析。任务是确保被验证类的方法在运行时不会做出**危害虚拟机安全**的行为。

           d) 符号引用验证：这一阶段发生在**虚拟机将符号引用转换为直接引用**的时候（解析阶段），主要是对类自身以外的信息进行**匹配性的校验**。目的是确保解析动作能够正常执行。

     2. 准备：正式为**类标量**变量分配内存（方法区）并设置初始值，

     3. 解析：

        1. 解析是虚拟机将常量池的符号引用替换为直接引用的过程。

        2. **符号引用 & 直接引用**

           ​	a) 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要	使用时能**无歧义地定位到目标即可**。**符号引用与虚拟机实现的内存布局无关**，引用的目标并不	一定已经加载到内存中。

           ​	b) 直接引用：直接引用可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的	句柄。**直接引用是与内存布局相关的。**

        3. c) 类或接口的解析

           d) 字段的解析

           e) 类方法解析

           f) 接口方法解析

  3. 初始化：运行静态代码 静态变量初始化，执行类构造器

  4. 使用 和 关闭 Using & Unloading

- 类加载器结构 [![image](https://camo.githubusercontent.com/e6bf0f48c99bb1f6eba5b567825fb173449aefa11946589416c8663537765069/68747470733a2f2f692e626d702e6f76682f696d67732f323032322f30372f32372f626666323431366231306439346531362e706e67)](https://camo.githubusercontent.com/e6bf0f48c99bb1f6eba5b567825fb173449aefa11946589416c8663537765069/68747470733a2f2f692e626d702e6f76682f696d67732f323032322f30372f32372f626666323431366231306439346531362e706e67) 

- 总体上讲， Java 的类加载器只分为两种: 第一种是 c++ 语言写的 启动类加载器：Bootstrap ClassLoader 第二种是 java 语言写的 其他各种类加载器。

- 第二种由可以分为 扩展类加载器， 应用程序类加载器 以及各种各样的自定义类加载器。

- Bootstrap ClassLoader 启动类加载器 是用于加载 %JDK_HOME%\jre\lib 目录下的 rt.jar, tools .jar 等 jdk 核心常见类的。
-  Extension ClassLoader 扩展类加载器 是用于加载 %JDK_HOME%\jre\lib\ext 目录下的 sunec.jar 等 jdk 扩展类的。 
- ApplicationClassLoader 应用类加载器 是用于加载 用户自定义的类，比如 cn.how2j.how2tomcat.test.TestClassLoader 这个类，就是由 ApplicationClassLoader 加载的。

- 自定义类加载器 一般是需要进行动态加载或者其他业务目的类加载器。

##### 双亲委派机制

（1）如果一个`类加载器`接收到了`类加载`的请求，它自己不会先去加载，会把这个请求委托给`父类加载器`去执行。

（2）如果父类还存在父类加载器，则继续向上委托，一直委托到`启动类加载器：Bootstrap ClassLoader`

（3）如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载，如果子类加载失败就会抛出`ClassNotFoundException`异常，这就是`双亲委派模式`

##### 破坏双亲委派机制

在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载。而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器（双亲委派模型的破坏者）就是很好的选择。

从图可知rt.jar核心包是有Bootstrap类加载器加载的，其内包含SPI核心接口类，由于SPI中的类经常需要调用外部实现类的方法，而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载，因此只能委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用。

显然这种**线程上下文类加载器的加载方式破坏了“双亲委派模型”**，它在执行过程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，当然这也使得Java类加载器变得更加灵活。

![image](https://i.bmp.ovh/imgs/2022/07/27/6caceff5217cfbc6.png)

- **沙箱安全机制**

1. 字节码校验器(bytecode verifier)
   确保lava类文件遵循lava语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。

2. 类装载器(class loader)
   防止恶意代码去干涉善意的代码，比如：双亲委派机制

​		守护了被信任的类库边界;	

​		将代码归入保护域，确定了代码的权限范围可以进行哪些资源操作

3. 存取控制器(access controller)
   存取控制器可以控制核心API对操作系统的存取权限，用户可以设定控制策略。

4. 安全管理器(security manager)
   安全管理器主要是核心API和操作系统之间的主要接口。比如实现权限控制，比存取控制器优先级高。

5. 安全软件包(security package) :
   java.security下的类和扩展包下的类，允许用户为应用增加所需要安全特性：安全提供者、消息摘要、数字签名keytools、加密、鉴别。

###### 举个例子

- 类加载器保护

自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar 包中的 javalangString.class），报错信息说没有 main 方法就是因为加载的 rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护