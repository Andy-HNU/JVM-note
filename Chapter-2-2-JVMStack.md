#### JVM Stack

![image](https://i.bmp.ovh/imgs/2022/07/28/45cfb13a1c320273.jpg)

#### 1.1 概述

**作用：**每一个线程拥有私有的一个栈，基本单位是栈帧-----用于保存方法的局部变量表，操作数，返回地址，动态链接，一些附加信息-----参与方法的调用和返回

**特点：**

- 速度：快速有效的分配方式，访问速度仅次于PC
- 操作：JVM 直接对 JVM Stack 操作只有 **入栈 & 出栈**，（方法调用 &  方法结束）
- GC：**栈不存在GC**

**异常：**

- 动态大小 **OutOfMemoryError**：
  -  Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个**OutOfMemoryError**异常
- 固定大小：
  - 创建线程时可指定栈容量大小，参数：-Xss
  - 如果线程请求分配的栈容量超过指定大小，那Java 虚拟机将会抛出一个**StackOverFlowError**异常

注：栈大小决定了方法调用深度/可传入的参数数量/可使用的局部变量数量

#### 1.2 栈运行

- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（**栈顶栈帧**）是有效的，这个栈帧被称为**当前栈帧**（Current Frame），与当前栈帧对应的方法就是**当前方法**（Current Method），定义这个方法的类就是**当前类**（Current Class）
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java 方法有两种返回函数的方式，**一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出**

#### 1.3 栈帧 Stack Frame

**栈帧概述**：

- 每个线程的栈的栈中数据以栈帧（Stack Frame）格式存在
- 在这个线程上（Current Thread）运行的每个方法 对应 一个栈帧
- 栈帧保存了维系方法执行过程中的数据信息

**栈帧内部结构：**

每个**栈帧**（Stack Frame）中存储着：

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）(或称为表达式栈)
- 动态链接（Dynamic Linking）：指向运行时常量池的方法引用
- 方法返回地址（Return Address）：方法正常退出或异常退出的地址
- 一些附加信息

![image](https://s3.bmp.ovh/imgs/2022/07/28/d9b238e95e158f3c.jpg)

##### 局部变量表

- **存储大小：** **局部变量表所需要的容量大小是编译期确定下来的**，并保存在方法的 Code 属性的 `maximum local variables` 数据项中。
  - 在方法运行期间是**不会改变局部变量表的大小的**

- **存储内容**：一组变量值存储空间，**主要用于存储方法参数和定义在方法体内的局部变量**，
  - 包括编译器可知的各种 Java 虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）
  - **对象引用**（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）
  - **returnAddress** 类型（指向了一条字节码指令的地址，已被异常表取代）

**局部变量表的基本单元 槽slot：**

- **初始化slot：**当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复制**到局部变量表中的每一个 Slot 上
- **存储结构：**在局部变量表中，32 位以内的类型只占用一个 Slot(包括returnAddress类型)，64 位的类型（long和double）占用两个连续的 Slot
  - byte、short、char 在存储前被转换为int，boolean也被转换为int，0 表示 false，非 0 表示 true
  - long 和 double 则占据两个 Slot
    - **如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可**。
    - 不允许采用任何方式单独访问其中的某一个 Slot

- **访问局部变量表：**JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量  - 
  - （slot.getByIndex(x) ,x :range(0,MaxOfSlot)）

- **特殊栈帧**：构造方法创建的栈帧

  - 局部变量表中slot的第一个 保存的是 该对象的this引用，其余的参数顺序排列
  - 为什么 static类/方法 没有this？
    - static 修饰的 对象 不存在于栈帧，自然没有this

- **Slot复用** （JVM层级优化）：

  - 如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而**达到节省资源的目的**。（下述代码段中，this、a、b、c 理论上应该有 4 个变量，c 复用了 b 的槽）

  - ```
    public class TryToSaveSlot{
    	public void Test(){
    		int a = 1;
    		{
    			int b = 2;
    			b = a-1;
    		}
    		int c = a -1;
    	}
    }
    ```

- 在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递

- **局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收**

##### 操作数栈（表达式栈）

​	**操作：**在方法执行过程中，由字节码指令决定 push / pop

- 概述：

主要用于博爱村计算过程中的中间结果，同时作为计算过程中变量的临时储存空间

**一次操作的示例过程：** 

- 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如，执行复制、交换、求和等操作，初始为空

**栈大小：** 编译时决定了栈所需最大深度 在方法的Code属性的max_stack数据项中，不可更改

**存储内容：**

- 栈中的任何一个元素都可以是任意的 Java 数据类型
  - 32bit 的类型占用一个栈单位深度
  - 64bit 的类型占用两个栈单位深度

- 操作数栈是封闭的容器，只能通过push/pop访问其中元素

- 校验：
  - 元素数据类型必须与字节码指令序列 严格匹配
  - 编译器编译期间会进行验证
  - 类加载过程中 类检验阶段的数据流分析阶段再次验证另外，我们说**Java虚拟机的解释引擎是基于栈的执行引擎**，其中的栈指的就是操作数栈

**注：** JVM的解释引擎是基于栈的执行引擎，其中“栈”指的就是操作数栈

###### HotSpot JVM 的栈顶缓存技术

**将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率**



##### 动态链接（指向运行时常量池的方法引用）

每个栈帧对应一个方法，每个栈帧中有一个特殊结构用于表明该栈帧属于哪一个方法，并作为引用指向方法区中的方法，目的是支持当前方法的代码可以实现动态链接

在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为**符号引用**（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

![image](https://s3.bmp.ovh/imgs/2022/07/28/6623d68730ab3fa6.jpg)

- **JVM是如何执行方法调用的？**

方法调用不同于方法执行，方法调用阶段的唯一任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。Class 文件的编译过程中不包括传统编译器中的连接步骤，一切方法调用在 Class文件里面存储的都是**符号引用**，而不是方法在实际运行时内存布局中的入口地址（**直接引用**）。也就是需要在类加载阶段，甚至到运行期才能确定目标方法的直接引用。



**与《深入理解计算机系统》：Chapter-7-动态链接 相似**



在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关

- **静态链接**：当一个字节码文件被装载进 JVM 内部时，如果被调用的**目标方法在编译期可知**，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
- **动态链接**：如果被调用的方法在编译期无法被确定下来，也就是说，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接

对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。**绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次**。

- 早期绑定：**早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时**，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
- 晚期绑定：如果被调用的方法在编译器无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式就被称为晚期绑定。

著作权归https://pdai.tech所有。 链接：https://pdai.tech/md/java/jvm/java-jvm-struct.html

##### 虚方法和非虚方法

- 如果方法在编译器就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法，比如**静态方法、私有方法、final 方法、实例构造器、父类方法**都是非虚方法
- 其他方法称为虚方法

##### 虚方法表

在面向对象编程中，会频繁的使用到动态分派，如果每次动态分派都要重新在类的方法元数据中搜索合适的目标有可能会影响到执行效率。为了提高性能，**JVM 采用在类的方法区建立一个虚方法表**（virtual method table），使用索引表来代替查找。非虚方法不会出现在表中。

每个类中都有一个虚方法表，表中存放着各个方法的实际入口。

Virtual method table 初始化时机：**虚方法表会在类加载的连接阶段被创建并开始初始化**，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。