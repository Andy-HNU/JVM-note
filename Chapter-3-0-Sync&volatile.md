#### 前言

Java内存模型和硬件内存架构是不同的。 硬件内存架构不区分线程堆栈和堆。 在硬件上，线程堆栈和堆都位于主存储器中。 线程堆栈和堆的一部分有时可能存在于CPU高速缓存和内部CPU寄存器中。 这在图中说明：

![image](https://s3.bmp.ovh/imgs/2022/08/03/7bc6e7411ed02987.png)

当对象和变量可以存储在计算机的各种不同存储区域中时，可能会出现某些问题。 两个主要问题是：

- Visibility of thread updates (writes) to shared variables.
- Race conditions when reading, checking and writing shared variables. 以下各节将解释这两个问题。

#### 对象共享后的可见性

如果两个或多个线程共享一个对象，而没有正确使用volatile声明或同步，则一个线程对共享对象的更新可能对其他线程不可见。

想象一下，共享对象最初存储在主存储器中。 然后，在CPU上运行的线程将共享对象读入其CPU缓存中。 它在那里对共享对象进行了更改。 只要CPU缓存尚未刷新回主内存，共享对象的更改版本对于在其他CPU上运行的线程是不可见的。 这样，每个线程最终都可能拥有自己的共享对象副本，每个副本都位于不同的CPU缓存中。

下图描绘了该情况。 在左CPU上运行的一个线程将共享对象复制到其CPU缓存中，并将其count变量更改为2.对于在右边的CPU上运行的其他线程，此更改不可见，因为计数更新尚未刷新回主内存中.

![image](https://s3.bmp.ovh/imgs/2022/08/03/b7cd16274aee61b0.png)

要解决此问题，您可以使用**Java的volatile**关键字。 volatile关键字可以确保直接从主内存读取给定变量，并在更新时始终写回主内存。

In short：

​	1. CPU-Cache-Memory 块传输方法是复制且层级间块大小不一致，当不同的线程访问同一块中的一个对象时，很有可能只有一部分对象被替换到上层，而在上层发生的修改不会及时写回（同步）到下层内存中的对象，导致不同线程间对象运行时不同步

#### 竞态条件

如果两个或多个线程共享一个对象，并且多个线程更新该共享对象中的变量，则可能会出现竞态。

想象一下，如果线程A将共享对象的变量计数读入其CPU缓存中。 想象一下，线程B也做同样的事情，但是进入不同的CPU缓存。 现在，线程A将一个添加到count，而线程B执行相同的操作。 现在var1已经增加了两次，每个CPU缓存一次。

如果这些增量是按先后顺序执行的，则变量计数将增加两次并将原始值+ 2写回主存储器。

但是，两个增量同时执行而没有适当的同步。 无论线程A和B中哪一个将其更新后的计数版本写回主存储器，更新的值将仅比原始值高1，尽管有两个增量。

该图说明了如上所述的竞争条件问题的发生：

![image](https://s3.bmp.ovh/imgs/2022/08/03/5c5cdb901e055ac3.png)

要解决此问题，您可以使用Java synchronized块。 同步块保证在任何给定时间只有一个线程可以进入代码的给定关键部分。 同步块还保证在同步块内访问的所有变量都将从主存储器中读入，当线程退出同步块时，所有更新的变量将再次刷新回主存储器，无论变量是不是声明为volatile

In short：

​	和上面volatile的原因相似，需要使用synchronized时 除了线程数据运行时不同步外，还会导致写回时引发的数据冲突